# DNN 얼굴 검출

다양한 객체검출과 관련되어있는 딥러닝 모델을 가져와서 openCV에서 실행하는 방법에 대해서 설명드리겠습니다.

openCV에서 제공하고있는 딥러닝 기반 얼굴검출 방법에 대해서 설명드리겠습니다.
정통적 영상처리방법 예를 들어 Haar-Cascade 방식같이 얼굴의 어두운 부분과 밝은 부분의 명암도를 이용해서 얼굴을 검출하는 방법도 있었지만
최근 딥러닝이 크게 발전하면서 딥러닝을 이용해 얼굴 검출하는게 더 좋은 성능을 낸다.  

openCV에서 최근 버전에서는 다 딥러닝 기반 얼굴검출하는 기능을 제공한다.  
얼굴검출방법은 기본적으로 SSD(Single Shot Multibox Detector)라는 네트워크 구조를 사용합니다. 
여기 내부의 알고리즘관련된 내용은 따로 공부하시기 바라구요.
기존 딥러닝 방식이 아닌 Haar Cascade같은 경우는 얼굴이 정면이 아니거나 좀 가려져있으면 인식을 잘 못하는 경우가 많습니다. 떨림도 심합니다.

딥러닝 기반의 경우 반이상이 가려지거나 옆모습이어도 잘 찾아줘요. 그래서 속도도 빠르고 정확도도 좋아요.

그래서 최근 딥러닝을 이용해서 찾는것이 효율적이고 성능이 좋습니다.

이러한 얼굴검출을 하는데 SSD 객체검출 알고리즘을 사용하게 됩니다. 2016년에 발표됐구요. 그 당시에 Faster R-CNN과 YOLOv1 알고리즘이 있었는데  

Faster R-CNN의 경우 잘 찾는데 느렸습니다. 7프레임정도 밖에 동작을 못하고 욜로는 45프레임이지만 성능이 낮습니다. 여기 mAP가 mean Average Precision약자고 정확도 개념으로 보시면 좋을 것 같습니다 높을수록 좋습니다. 

그래서 속도를 중요시하자니 정확도가 떨어지고 정확도를 높이자니 속도가 낮은, 이때 SSD는 둘다 잡았으니 한동안 각광을 받았습니다. 하지만 이게 2016년에 나온거다 보니 더 좋은 성능 알고리즘이 많이 나왔죠. 현재 YOLO 버전 5까지 나왔으니까요.

어쨌거나 OpenCV에서 제공되는 얼굴검출은 SSD 기반으로해서 학습된 결과를 제공해줍니다. 

* OpenCV DNN 얼굴 검출(SSD) 입력
1. Size : (300,300) -> 일단 입력영상은 300by300으로 리사이즈를 해줍니다.
2. Scale : 1(0~255) -> 픽셀값은 0~255
3. Mean : (104,177,123)
4. RGB : False (OpenCV가 BGR순서로 되어있기떄문에 RGB로 바꿀필요는 없습니다. False를 해주시구요)

* OpenCV DNN 얼굴 검출(SSD) 입력
1. out.shape=(1,1,200,7) -> 출력으로 나오는 ndarray 형식은 4차원 형태인데 1,1,200,7입니다. 앞의 1 두개는 의미없는 더미이구요. 뒤에 두개를 쓰시면됩니다.
2. detect=out[0,0,:,:] -> 그래서 앞에껄 무시하기 위해서 0,0을 넣어줍니다.  
![image](https://user-images.githubusercontent.com/76835313/127801119-91a7a483-c3d0-40ca-abf6-17beeda8c65e.png)
앞에 두개는 무시하시면 되구요. c는 confidence값으로 확률입니다. 이때 저희는 threshold 값을 설정해야합니다. 예를들어 0.5이상일 경우 얼굴이라고 간주한다라는 값을 줘야겠죠? 
x1,y1 / x2,y2는 바운딩 박스의 좌측상단과 우측하단점입니다. 중요한건 이 x,y좌표가 0~1사이로 nomalize되어있습니다. 그래서 여기값에다가 Width, Height값을 곱해주어야 실제 좌표값이 됩니다.

코드를 보면 다음과 같습니다

blobFromImage 함수를 이용해서 현재 프레임 크기를 300by 300으로 resize해서 mean값은 104,177,123값을 씁니다. 그래서 blob이라고하는 4차원 객체가 생성됩니다.  

detect=out[0,0,:,:]
그 결과를 out형태로 ndarray로 줍니다. 앞서 말씀드린것처럼 뒤에 두개 차원만 이용합니다.  

for i in range(detect.shape[]):
전체 행을 순회를 하면서 컨피던스 값이 0.5보다 클 경우에만 밑의 코드를 사용합니다. 

if confidence <0.5:
  break;
> 이렇게 해주는게 전체 코드를 다 돌리지않고 중간에서 끊어주는게 효율적이어서 그렇습니다. 
