딥러닝 : ~~ 도 가능한 머신러닝 기법

머신러닝 : 컴퓨터야 이것좀 배워봐 - 이건 개 이건 고양이 SVM 같은거지
1. 개와 고양이 특징을 직접 정해줘야한다. 
2. 사람의 가이드라인이 필요

딥러닝 : 가이드라인 컴퓨터야 니가 다 알아서해 (가이드 불필요)  
- 개와 고양이 몰라도 머신러닝 가능하다.
- 유방암 잘몰라도 유방암진단 AI는 가능하다.
* 뉴럴네트워크를 이용해 머신러닝을 진행하는 것
* 뉴런과 시냅스를 통해 뇌의 동작이 이루어진다. 
* 그모양을 본따 머신러닝 알고리즘 만든게 딥러닝이다. 

* 딥러닝이 잘하는분야
* image classification, object detection
* sequence data 분석 & 예측

* 머신러닝의 종류
1. Supervised Learining : 데이터에 정답이 있고 정답예측 모델 만들 때 -> 라벨링이 되어있음
2. Unsupervised Learning : 데이터에 정답이 없다. -> 컴퓨터야 니가 알아서 분류해줘 
3. Reinforcement Learning : 컴퓨터에게 게임가르친다. 너가 알아서 타이밍 맞춰서 방향키 눌러라. 컴퓨터는 공을 놓치기도 하지만 벽돌을 하나 깰때마다 1점을 주거나 공을 읽으면 -10을 준다. 그다음 최종점수 높이도록 알아서 방향키 움직여봐라.

* 머신러닝
1. ![image](https://user-images.githubusercontent.com/76835313/135956888-1aadc07e-3718-4488-a843-3cf4f99332e1.png)
- 사람이라면 6월과 9월 절반씩 영향이 있어서 0.5씩 곱해 70점이 될것같다.
2. ![image](https://user-images.githubusercontent.com/76835313/135956996-f071a999-0726-4f30-baf6-aa2d3e8ac449.png)
3. ![image](https://user-images.githubusercontent.com/76835313/135957010-6e39518a-262a-455c-b31e-78295a7f5e0d.png)
4. 그런데 컴퓨터에게 w1, w2를 찾으라고 시키는게 머신러닝이다. 즉 가중치를 찾게한다. (weight)
5. ![image](https://user-images.githubusercontent.com/76835313/135957097-551094fd-25e9-42a7-8e54-01733935467d.png)
- 6월, 9월 성적과는 관련이 없는데 수능성적엔 관련있는 요소가 있을 수 있다. 그래서 bias를 더한다. 
6. ![image](https://user-images.githubusercontent.com/76835313/135957261-c2c23f83-e62f-4d46-aeca-c3250ca51bc1.png)
- 실제 수능 성적과 예측값을 비교해 오차를 구한다. 이 오차값을 최소화 방향으로 w값을 수정한다. 
7. ![image](https://user-images.githubusercontent.com/76835313/135957437-94b93331-c0f3-4c22-aa29-b51301b36c03.png)
이렇게 생긴걸 퍼셉트론이라한다.
8. ![image](https://user-images.githubusercontent.com/76835313/135957476-3515220d-52b1-46f1-be0d-870eacb256de.png)
9. 중간에 생각과정이 있느면 뉴럴네트워크이며 이게 여러개 있으면 deep neural network이다.
10. 이 hidden layer가 잠깐 생각 저장하는 공간이라고 봐도 된다.

1. ![image](https://user-images.githubusercontent.com/76835313/135957766-4f454cbc-0d84-41c5-8d80-876aa2d7498b.png)
- 이건 머신러닝이라기보단 인간러닝이다.
2.  ![image](https://user-images.githubusercontent.com/76835313/135957880-ea50ebf3-dcc5-4ef1-8b6e-2ec6a2afb629.png)
3.  ![image](https://user-images.githubusercontent.com/76835313/135957914-cc1cb11a-f528-4ad9-8604-ca291a1e0c45.png)
- 이 과정을 feature extraction 이라고 한다.
- 전통 머신러닝에서는 사람이 바퀴인지 범퍼인지 가이드를 해줘야 했다.

## hidden layer
1. 하나의 동그란건 노드이다.
2. node는 숫자일 뿐이다.
3. 그 방법은 퍼셉트론 계산처럼한다. 
4. 이 노드들과 연결된 노드들을 w곱해서 다 더한다. 
5. w는 미지수이다. 컴퓨터가 찾는다.
6. 이 노드는 h1, h2로 표현한다. 
7. ![image](https://user-images.githubusercontent.com/76835313/135964800-d71b622d-5f79-4ecd-ac8a-258e5482a246.png)
8. 그런데 간혹가다가 오차가 -10인경우 다 더할때 오히려 오차가 주는 경우가 생긴다. 
9. 그래서 제곱해서 절대값 양수로 만든다.  -> 평균제곱오차 
10. 컴퓨터야 평균제곱오차를 최소화하는 w값들을 찾아라 -> loss function, cost function 이다.
11. ![image](https://user-images.githubusercontent.com/76835313/135965018-58c54f91-01e6-4017-89d0-39b3662eeea6.png)
12. 여기서 햇 ^ 은 예측값이라고 볼 수 있다. 햇 ^ 이없는 것은 실제값이다. 
13. ![image](https://user-images.githubusercontent.com/76835313/135965151-a4e39484-8c8f-4121-a56e-ae429b86d090.png)

## 활성함수가 없으면 뉴럴네트워크가 아니다 : Activation function

지금까지 작성했던 수능점수 예측모델은 결함이 하나 있습니다.  

중간에 히든 레이어를 넣든 안넣든 예측결과는 똑같을걸요?   

실제로 머신러닝 돌려보면 레이어 있나없나 거의 결과가 똑같습니다.   
 
우리가 의도했던 "뇌처럼 생각하는 공간" 역할의 레이어가 제 역할을 해주지 못하고 있는겁니다.  

그러니 앞으로 복잡한 예측도 전혀 못할 것 같군요.  

이걸 해결하고 싶으시면 레이어안의 Node 연산결과를 짜부라트리면 됩니다.   

활성함수 안에 집어넣어서요.   

활성함수는 여러가지 종류가 있습니다.  

hyperbolic tangent  

sigmoid  

softmax  

rectified linear  

등이 있습니다.   

![image](https://user-images.githubusercontent.com/76835313/135965287-bef22315-96f5-47b8-8e89-386b1e64e9bb.png)


▲ 예를 들면 sigmoid 활성함수는 이렇게 생겼습니다.   

여기 x 부분에 여러분이 연산한 node값을 집어넣자는겁니다.  

그러면 값이 0과 1사이로 압축되어서 나오게 됩니다.   

이렇게 node 값을 한번 짜부라트리면 아까와같은 문제가 발생하지 않습니다.  

의도했던 대로 약간 더 복잡한 예측을 할 수 있다는 것입니다.   

활성함수는 마음에 드는거 아무거나 써보시면 됩니다.   
 
물론 특정한 레이어마다 권장하는 활성함수종류는 있을 수 있는데 앞으로 자연스럽게 습득하게 될겁니다.   

![image](https://user-ima ges.githubusercontent.com/76835313/135965643-fa77995d-cc56-4b7a-b746-2957b6005afc.png)

![image](https://user-images.githubusercontent.com/76835313/135965660-1d03f176-eb54-4aa2-a231-1e405e4a5cda.png)
![image](https://user-images.githubusercontent.com/76835313/135965674-d882076a-f9f5-4b47-acce-58ec1209e135.png)


* 활성함수없이 예측 : 선형적이고 단순한 예측
* 활성함수포함한 예측 : 비선형적이고 복잡한 예측가능

* Activation function이 없으면 딥러닝, 뉴럴네트워크가 아니다.
* 모든 레이어에이쓴게 좋지만 출력층에는 없을 수도 있다. 출력결과가 0~1로 표현하고싶으면 쓴다.

* w값을 때려맞춰라가아니라 역전파로 w값을 업데이트한다.

# w값 찾는 법은 경사하강법을 사용합니다.

= 현재 w1값에서의 접선의 기울기를 w1에서 뺀다. 
-> 따라서 기울기라 1이면 3에서 2로 내려간다. 0.5라면 기울기가 -1이므로 1.5가 된다. 그래서 알아서 최저점을 찾는다.  
![image](https://user-images.githubusercontent.com/76835313/135968035-d858d65a-9465-402c-b824-85929af48985.png)
: w1의 변화가 총손실 E에 얼마나 큰영향을 끼치는가?
**하지만 기울리가 아니라 정확한 표현은 "w1이 쪼금 변하면 E는 얼마나 변하는가(일명 편미분)" 이다.
정리하면,  
1. w값들 랜덤으로 찍는다
2. w값 바탕으로 총손실 E를 계산한다.
3. 경사하강으로 새로운 w값 업데이트한다.   
![image](https://user-images.githubusercontent.com/76835313/135968211-2e0ba15c-ad56-4cc0-92a9-25d420ef6c76.png)
4. w값 바탕으로 총손실 E를 계산한다.
5. 경사하강으로 새로운 w값 업데이트 -> 무한반복 총손실 E가 안줄어들때까지

w값은 컴퓨터에게 찾게 시키겠지만 찾는 방법은 알고계셔야합니다.   

경사하강법 (Gradient descent)라는 간단한 방법을 이용합니다.   

알맞은 w1값을 찾고 싶으면 그냥 w1의 변동이 총손실 E에 얼마나 영향을 끼치는지 계산을 하신 다음  

그걸 기존 w1에서 뺍니다.  

빼면 뭔가 나오겠죠? 그걸 새로운 w1값으로 설정하시면 됩니다.  

파이썬으로 설명하자면  

 

**새로운w1 = 기존w1 - (기존w1이 아주 쪼금 0.0001 변하면 총손실 E가 얼마나 크게 변하는지)**  
입니다.  

 

 

w2도 마찬가지고 w3도 마찬가지입니다.  

왜 이런 방법을 쓰는지는 영상에서 그림으로 보시면 이해가 빠르겠군요.  

경사를 타고 하강하면 결국은 총손실을 최소로 만드는 w값이 나오니까요.  

 

 

**하지만 그냥 뺄셈만 하면 local minima라고 부르는 가짜 최저점에 빠져서 더 이상 경사하강이 일어나지 않을 수 있습니다.**  

**그래서 w1 = w1 - (w1이 아주 쪼금 0.0001 변하면 총손실 E가 얼마나 크게 변하는지) * learning rate 를 하셔야합니다.**

learning rate는 여러분이 자유롭게 1,2,3 이렇게 설정하실 수 있는 상수이며   

**이걸 곱해주면 지엽적인 local minima를 뛰어넘으며 학습이 잘 진행될 수 있습니다.**   

 

 

하지만 learning rate 값을 고정해두는 것도 학습 능률을 저하시킬 수 있기 때문에  
  
이 값을 다이나믹하게 변경시키는 알고리즘이 몇개 있습니다. **Learning rate optimizer**라고 부르는 것들입니다.   

**SGD, Momentum(가속도를 유지하자), AdaGrad(자주변하는 w는 작게, 자주변하면 크게), RMSProp(AdaGrad인데 제곱), Adam(RMSProp_Momentum)** 등 여러개가 있으며 우리도 코드짤 때 활용해볼겁니다.  

# W값 역전파 알고리즘으로 업데이트하는 법 (back propagation)

![image](https://user-images.githubusercontent.com/76835313/135968844-4649221d-0d48-4912-942b-03e9583e096f.png)


그래서 w값을 이런 식으로 업데이트를 한다고 했는데

저 수식에 있는 이상한 값들 계산은 어떻게 하는지 예제를 통해 알아보도록 합시다. 

저거 동그란 ∂모양 기호는 "w1이 쪼오금 변하면 E는 얼마나 크게 변하는가~" 라는 편미분을 하라는 기호인데

중학생 난이도로 설명해드릴 것이니 편미분 그런거 몰라도 걱정하지 않으셔도 됩니다.

그리고 이건 어짜피 텐서플로우가 알아서 해주기 때문에 내가 딥러닝 시험볼거다, 딥러닝으로 석박사할거다 그런거 아니면 다음 강의로 스킵하셔도 상관없습니다.


# 텐서플러우

 16 분
Tensorflow 2 빠른기초 & 텐서플로우를 쓰는 이유 혹시 아십니까


 

 

 

텐서플로우에서 사용하는 텐서라는 자료형이 있습니다. 

수학에서의 행렬, 벡터를 파이썬으로 표현하고싶을 때 사용하면 유용합니다. 

갑자기 행렬이야기는 왜 나온 것이고 텐서를 왜 쓰는 것인지도 알아보도록 합시다. 

 

 

 

텐서플로우 배우면 딥러닝할 수 있는게 아닙니다. 

그냥 딥러닝 수학계산을 조금 더 쉽게 도와주는 라이브러리일 뿐입니다. 

근데 이걸 직접 파이썬 쌩코딩으로 짜면 매우 코드가 길고 복잡해지기 때문에

- 최종 예측값 (yhat) 계산

- w값 업데이트 (back propagation)

- learning rate 만들기

- loss function 만들기 

- 레이어 만들기 

 

이런 것들을 매우 쉽게 코드한줄로 처리할 수 있게 도와주는 라이브러리인 텐서플로우를 씁니다. 

 

 

 

 

 

텐서플로우는 tensor 라고 부르는 기본 자료형을 활용해서 정보들을 저장합니다. 

Q. 뭔정보냐고요?

딥러닝 뉴럴네트워크에 집어넣을 input 값들이나 w값들을 텐서로 저장할 수 있습니다. 

 

텐서 = tf.constant( [1,2,3] )
print(텐서)
이런 식으로 숫자같은걸 텐서로 저장할 수 있습니다. 출력하면 "tensor입니다~" 라고 나옵니다. 

 

 

 

 

Q. 뭐야 리스트랑 똑같은데여 그냥 파이썬 리스트에 저장하면 안되나요? 

됩니다. 원하는 w값들을 [1,2,3] 이렇게 파이썬 리스트로 저장해두고 쓸 수도 있습니다.

근데 자료들의 dimension이라고 부르는 차원이 좀 높아지면 tensor가 다루기 편합니다. 

특히 이미지같은거 처리할 땐 리스트안의 리스트안의 리스트 이런 자료들을 다루게 될 텐데 

(그리고 이런 자료를 3차원 자료라고 하는데)

파이썬 리스트로만 만들면 넘나 처리하기 어려워서 그렇습니다. 

 

 

Q. 그럼 뭐가좋냐고요? 

텐서를 이용하시면 노드에 들어갈 값 연산할 때 코드가 매우 짧아집니다. 

예를 들어봅시다. 

 

 



 

이런 뉴럴 네트워크가 있다고 칩시다. 

그럼 노드1에 들어갈 숫자는 어떻게 계산하면 될까요? 

노드1 = 10*w1 + 20*w2 + 30*w3 + 40*w4
이런 식으로 코드를 짜겠죠. 

이전 노드 갯수가 4개라 망정이지 100개면 어쩔겁니까. 코드가 매우 길고 더러워집니다. 

 

 

 

 

근데 이전 노드의 값들과 w값들을 전부 행렬이란 것에 담아버리면 ...

(10 20 30 40) (w1 w2 w3 w4) 요렇게요. 

개발자 입장에서 저걸 좀 더 쉽게 표현할 수 있습니다.

 

 


행렬이 뭔데요 님만 아는거 쓰지마셈
 

 

 

행렬은 곱셈을 약간 특이하게 할 수 있습니다. 이걸 이용하면 노드1값 연산이 편리해집니다. 

행렬의곱 (dot 연산) 연산 법칙이라는게 있는데 ..

x 이 기호말고 º 이런 기호로 행렬 두개를 곱해라~ 라고 써있으면 

 



 

1 x 5 + 2 x 6 + 3 x 7 + 4 x 8 이런 식으로 연산해야합니다. 

약간 특이하죠? 더 알아보고 싶으면 행렬 곱연산을 검색해보도록 합시다. 

(참고로 행렬 곱연산을 하고 싶으면 왼쪽행렬 세로줄의 갯수와 오른쪽 행렬 가로줄의 갯수가 같아야합니다. )

 

 

 

 

암튼 그래서 아까 노드1값 연산할 때 

 



 

노드1 = 10*w1 + 20*w2 + 30*w3 + 40*w4 ...
이런 식으로 코드를 짜는게 아니라 님이 행렬을 알고 있다면 

 

 

행렬X = (10, 20, 30, 40)
행렬W = (w1, w2, w3, w4)

노드1 = 행렬X와 행렬W 가로세로 뒤집은걸 dot연산 해주셈
이렇게 쓸 수 있습니다. 이거나 저거나 똑같이 노드1을 계산할 수 있습니다. 

(가로세로 왜 뒤집냐면 그래야 행렬 곱셈이 가능하니까요)

 



▲ 그림으로 표현하자면 이렇습니다. 

 

w값들이 100개 이상으로 많아지면 행렬에 담아서 곱해버리는게 훨씬 더 코드가 짧아지겠죠? 

이런 짓거리가 가능하기 때문에 뉴럴네트워크 계산할 때 텐서플로우를 쓴다는겁니다. 

이거 행렬연산을 파이썬 코드로 어떻게 짜냐면..

 

행렬X = tf.constant( [ [10,20,30,40] ])
행렬W = tf.constant( [ [w1,w2,w3,w4] ])
행렬W뒤집은거 = tf.transpose(행렬W)

노드1 = tf.matmul( 행렬X, 행렬W뒤집은거 )
print(노드1)
텐서플로우 함수들을 이렇게 쓰시면 됩니다.

그럼 아까처럼 길게 곱셈 덧셈 하는 것보다 약간 더 코드가 짧아질 수 있습니다.  (노드 갯수가 많아지면요)

암튼 w1 이라는 이상한 미지수 대신 실제 숫자같은거 암거나 집어넣어보시면 실제 노드1값 계산도 해보실 수 있겠군요.

# 의류사진 구분 AI 만들기 : 딥러닝으로 이미지를 학습시키려면

이미지를 학습시키면 이 이미지는 사람인지 강아지인지 파악할 수 있습니다. 

자율주행, 암진단, SNS 서비스 등에 활용할 수 있겠죠? 

일단 이미지를 학습시키는 방법에 대해 알아봅시다. 

근데 문제가 있습니다. 뉴럴네트워크엔 숫자만 넣을 수 있습니다.

이미지를 넣고싶으면 이미지를 숫자로 바꾸는 간단한 전처리과정을 거쳐야합니다. 

이번 강의에선 전처리는 스킵할 수 있는 쉬운 프로젝트인 "쇼핑몰 의류이미지 자동분류" 프로젝트를 진행해보도록 합시다. 

 

 

 

일단 가장 큰 문제는 이미지를 숫자로 바꿔서 넣어야합니다. 

그러기 위해 사전 지식을 몇개 소개해드리자면.. 

 

① 색상은 숫자로 쉽게 표현가능합니다. 

빨간색이 숫자로 무엇인지 아십니까. (255, 0, 0) 입니다. 

초록색이 숫자로 무엇인지 아십니까. (0, 255, 0) 입니다. 

흔히 RGB 칼라 코드라고 부르는 색상표현법을 사용하면 색상정보는 숫자로 쉽게 바꿀 수 있습니다. 

 ![image](https://user-images.githubusercontent.com/76835313/135974234-f7eb07e1-e177-4da4-9f5f-f1162b72fdc9.png)


② 그리고 모든 jpg png 이미지는 픽셀로 이루어져있습니다. 



 

▲ 이미지를 확대하면 네모칸이 보이죠? 이거 네모칸 하나가 픽셀입니다. 

이게 수백만개 모이면 하나의 멋진 이미지가 되는 것이고요. 

그리고 그림처럼 픽셀마다 색상은 1개가 존재합니다. 

그럼 이제 이미지를 숫자로 어떻게 바꿀지 대충 느낌이 오지 않습니까. 

 # CNN
 
 ![image](https://user-images.githubusercontent.com/76835313/135975546-bb1238ef-ee1b-416a-8a09-5e1ee52044a3.png)

1. 기존에는 창의력이 없는 딥러닝이다. 그래서 이미지에서 중요한 정보를 추려서 복사본 20장을 만든다.
그곳엔 이미지의 중요한 feature, 특성이 담겨있다.
이걸로 학습한다. 

2. 실제 지도학습할 필요없이 딥러닝에서는 convolutional layer로 feature extraction을 한다.  
즉, 이미지의 복사본 20장을 만든다.

3. 커널을 거쳐서 feature map을 만든다.
 ![image](https://user-images.githubusercontent.com/76835313/135975946-37af5104-82dc-482d-8b45-12eabd48568c.png)

![image](https://user-images.githubusercontent.com/76835313/135975975-1d6d9e80-df9a-45bb-898e-5d6e2a0590d0.png)
![image](https://user-images.githubusercontent.com/76835313/135976055-510dc950-efcd-41c6-bd90-51a1b2623ba7.png)
![image](https://user-images.githubusercontent.com/76835313/135976073-bce3760e-3091-471c-93cf-baaaf215ec92.png)
- 그냥 줄이는게 아니라 중요한 부분을 유지한채로 줄인다.  MAX Pooling은 최댓값만 추린다. 
![image](https://user-images.githubusercontent.com/76835313/135976182-ca3ebaf2-3a73-4a95-8d86-92eb3cd549c5.png)
따라서 이미지 위치에 영향을 받지않는다.

* CNN

![image](https://user-images.githubusercontent.com/76835313/135979332-e02dfd45-22ee-4c36-9813-8de1f9f1e24f.png)
1. input Image
2. Filter
3. Convolution Layers
4. Pooling
5. Flattening



10 x 10 사이즈의 이미지를 숫자로 바꾼다면

[ 픽셀1의 색상코드, 픽셀2의 색상코드 ... 픽셀100의 색상코드 ]
이렇게 리스트 안에 담으면 끝입니다. 

근데 보통은 가로 세로 10 x 10 사이즈의 리스트에 담습니다. 그니까 이런 모습? 

 

[ [ 픽셀1의 색상코드, 픽셀2의 색상코드 ... 픽셀10의 색상코드 ]
  [ 픽셀11의 색상코드, 픽셀12의 색상코드 ... 픽셀20의 색상코드 ]
   ...
  [ 픽셀91의 색상코드, 픽셀92의 색상코드 ... 픽셀100의 색상코드 ] ]
이게 10 x 10 사이즈의 이미지를 숫자로 치환하는 법입니다.

이건 노가다로 하진 않고 쉽게 변환해주는 라이브러리를 가져다 쓰시면 되겠습니다. 

 

참고로 흑백사진은 색상코드가 (0,0,0) 이게 아니라 (0) 이거 숫자 하나만 필요합니다.

0부터 255까지 들어갈 수 있습니다. 

그래서 배울 땐 흑백사진부터 시작합시다. 



 15 분
정확도 상승! 컨볼루션 모델 만들기 & 학습

 

 

 

 

저번시간 좋은걸 배웠으니 이번시간엔 그 좋은걸 가지고 모델을 수정해보도록 합시다. 

2D이미지의 경우엔 Conv2D + MaxPooling 레이어를 이용하시면 됩니다. 

이 레이어는 원하는 만큼 반복해서 적용하실 수 있습니다. 

그리고 이 작업이 끝났다면 Flatten, Dense, 출력 순으로 레이어를 구성해주는게 일반적이니 우리도 그렇게 합시다. 

 

 

맨 처음에 trainX와 함께 testX라는 데이터셋도 만들었습니다.

이 데이터는 1만개 정도의 테스트용 데이터셋인데 학습이 다 끝나고 새로운 데이터로 정확도를 검증하려고 사용하는 것입니다.

학습이 다 끝나고 정확도를 다시한번 검증, 테스트하고 싶으면 model.evaluate( textX, testY) 라고 사용하시면 됩니다.

그게아니라 학습 중간중간 epoch 하나 끝날 때마다 테스트하고 싶으시면 model.fit( validation_data=(testX,testY) ) 이렇게 해주시면 됩니다.

 

 

 

대부분의 모델은 학습을 오래하면 트레이닝 데이터셋 accuracy는 계속 높아지지만 

테스트 데이터셋 accuracy는 그보다 훨씬 적은 현상이 나타날 수 있습니다.

일례로 강의에선 트레이닝 accuracy : 0.94 & 테스트 accuracy : 0.915 이렇게 나왔죠? 

이걸 overfitting 이라고 합니다.

모델이 트레이닝 데이터를 과도하게 학습해서 트레이닝 데이터만 잘 예측하는겁니다. 

그래서 새로운 데이터를 갖다줬을 때 예측을 잘할 수 없게되니 좋은 모델이라고 할 수 없겠죠. 

overfitting이 많이 일어나는지 언제나 체크하고 이를 방지하기 위한 여러가지 방법을 도입하면 됩니다.

한가지는 그냥 테스트/val accuracy가 낮아지기 전에 epoch을 중지시키는 것이 가장 쉬운 방법인데

다른 것들은 강의진행하며 하나둘 씩 알게될겁니다. 














